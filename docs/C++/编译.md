---
sidebar_position: 1
---

# 编译
学C/C++之前需要了解的基本编译原理

## 一、基本概念
现代C++编译一般都需要三步，分别对应 **构建生成器**、**构建工具** 和 **编译器**：

### **1. 构建生成器（Build Generators）**  
生成构建系统所需的配置文件（如 `Makefile`、`build.ninja` 等）。  
| 工具        | 角色           | 输入                  | 输出                  | 可搭配的工具                     | 典型使用场景                     |
|-------------|----------------|-----------------------|-----------------------|----------------------------------|----------------------------------|
| **CMake**   | 构建生成器     | `CMakeLists.txt`      | `Makefile`、`build.ninja`、`.sln` 等 | Ninja、Make、MSBuild、Xcode     | 跨平台项目配置，生成构建文件       |
| **MSBuild(VS)** | 构建工具       | `.vcxproj`、`.sln`    | 目标文件/可执行文件   | MSVC                            | Visual Studio项目构建            |
| **Xcode**   | IDE/构建工具   | `xcodeproj`           | 目标文件/可执行文件   | Clang、Apple Clang             | macOS/iOS开发                    |

---

### **2. 构建工具（Build Tools）**  
根据构建文件执行编译任务，调用编译器生成最终二进制文件。  
| 工具        | 角色           | 输入                  | 输出                  | 可搭配的工具                     | 典型使用场景                     |
|-------------|----------------|-----------------------|-----------------------|----------------------------------|----------------------------------|
| **Ninja**   | 构建工具       | `build.ninja`         | 目标文件/可执行文件   | GCC、Clang、MSVC                | 快速增量编译（替代Make）         |
| **Make**    | 构建工具       | `Makefile`            | 目标文件/可执行文件   | GCC、Clang、MSVC（通过`nmake`） | 传统Unix项目的编译               |
| **MSBuild** | 构建工具       | `.vcxproj`、`.sln`    | 目标文件/可执行文件   | MSVC                            | Visual Studio项目构建            |
| **Xcode**   | IDE/构建工具   | `xcodeproj`           | 目标文件/可执行文件   | Clang、Apple Clang             | macOS/iOS开发                    |

---

### **3. 编译器（Compilers）**  
将源代码（`.c`/`.cpp`）编译为目标文件或可执行文件。  
| 工具        | 角色           | 输入                  | 输出                  | 可搭配的工具                     | 典型使用场景                     |
|-------------|----------------|-----------------------|-----------------------|----------------------------------|----------------------------------|
| **GCC**     | 编译器         | `.c`/`.cpp` 源文件    | 目标文件/可执行文件   | Ninja、Make、CMake              | Linux/Unix环境下的编译           |
| **MSVC**    | 编译器         | `.c`/`.cpp` 源文件    | 目标文件/可执行文件   | Ninja、Make（`nmake`）、MSBuild | Windows平台编译（Visual Studio） |
| **Clang**   | 编译器         | `.c`/`.cpp` 源文件    | 目标文件/可执行文件   | Ninja、Make、CMake              | 跨平台或需要更严格代码检查的项目 |

---

### 分类说明：
1. **构建生成器**：  
   负责生成构建系统所需的配置文件（如 `Makefile`、`.sln`），不直接参与编译。  
   - **CMake** 是跨平台的核心工具。  
   - **MSBuild** 和 **Xcode** 是特定平台（Windows/macOS）的构建工具，但也能生成项目文件。

2. **构建工具**：  
   根据构建文件调用编译器，管理编译流程（如依赖检查、并行编译）。  
   - **Ninja** 和 **Make** 是通用的轻量级工具。  
   - **MSBuild** 和 **Xcode** 是平台绑定的工具，与编译器深度集成。

3. **编译器**：  
   实际将源代码转换为二进制文件的工具，由构建工具调用。  
   - **GCC** 和 **Clang** 是跨平台的开源编译器。  
   - **MSVC** 是微软的专有编译器，主要支持Windows。  

### 协作关系示例：
- **构建生成器 → 构建工具 → 编译器**：  
  `CMake` 生成 `build.ninja` → `Ninja` 调用 `GCC` 编译 → 生成可执行文件。  
- **IDE 集成**：  
  `Xcode` 作为构建工具和IDE，直接调用 `Clang` 完成编译。

## 二、关于编译器

以下是一些关于 **C++ 编译器** 的核心知识，这些概念可以帮助更好的理解cmake等构建工具的强大，涵盖交叉编译、链接器、编译流程等关键概念：

---

### **1. 编译流程概述**
C++ 代码从源码到可执行文件的流程分为四个阶段：

| 阶段          | 输入             | 输出             | 主要任务                                     | 工具示例           |
|---------------|------------------|------------------|--------------------------------------------|--------------------|
| **预处理**    | `.cpp`, `.h`     | `.i` (预处理后文件) | 展开宏、包含头文件、条件编译                | `gcc -E`, `clang -E` |
| **编译**      | `.i` 或 `.cpp`   | `.s` (汇编代码)   | 将源码转换为平台相关的汇编代码              | `gcc -S`, `clang -S` |
| **汇编**      | `.s`             | `.o` (目标文件)   | 将汇编代码转换为机器码（二进制目标文件）    | `as` (汇编器)       |
| **链接**      | `.o` 和库文件    | 可执行文件或库    | 合并目标文件与库，解析符号依赖              | `ld` (链接器)       |

**示例命令**：
```bash
g++ -E main.cpp -o main.i    # 预处理
g++ -S main.i -o main.s      # 编译为汇编
g++ -c main.s -o main.o      # 汇编为目标文件
g++ main.o -o main           # 链接生成可执行文件
```

---

### **2. 交叉编译（Cross-Compilation）**
**定义**：在一种平台上（如 x86_64 Linux）编译生成另一种平台（如 ARM 嵌入式设备）的可执行代码。

#### **关键步骤**：
1. **安装交叉编译工具链**  
   工具链通常包含交叉编译器、交叉链接器、目标平台的标准库等。  
   - 示例工具链：  
     - ARM: `arm-linux-gnueabihf-g++`  
     - Android NDK: `aarch64-linux-android-g++`

2. **配置编译参数**  
   指定目标平台的架构、系统、库路径等。  
   ```bash
   # 示例：使用 ARM 工具链编译
   arm-linux-gnueabihf-g++ -march=armv7-a main.cpp -o main_arm
   ```

3. **使用 CMake 交叉编译**  
   创建 `toolchain.cmake` 文件，定义交叉编译变量：  
   ```cmake
   set(CMAKE_SYSTEM_NAME Linux)
   set(CMAKE_C_COMPILER arm-linux-gnueabihf-gcc)
   set(CMAKE_CXX_COMPILER arm-linux-gnueabihf-g++)
   set(CMAKE_SYSROOT /path/to/sysroot)
   ```
   编译命令：  
   ```bash
   cmake -DCMAKE_TOOLCHAIN_FILE=toolchain.cmake ..
   make
   ```

#### **典型场景**：
- 嵌入式开发（ARM/MIPS）  
- 跨平台应用开发（Windows/Linux/macOS）  
- 移动端开发（Android/iOS）

---

### **3. 链接器（Linker）**
**作用**：将多个目标文件（`.o`）和库（`.a`/`.so`/`.dll`）合并为最终的可执行文件或共享库。

#### **核心任务**：
1. **符号解析（Symbol Resolution）**  
   - 确保每个符号（函数、变量）有且仅有一个定义。
   - 常见错误：  
     - `undefined reference to ...`（符号未定义）  
     - `multiple definition of ...`（符号重复定义）

2. **地址分配**  
   为代码和数据分配内存地址，处理重定位（Relocation）。

3. **库链接**  
   - **静态库（`.a`/`.lib`）**：代码直接嵌入可执行文件。  
     ```bash
     ar rcs libmath.a add.o sub.o    # 创建静态库
     g++ main.cpp -L. -lmath -o main # 链接静态库
     ```
   - **动态库（`.so`/`.dll`）**：运行时加载，节省内存。  
     ```bash
     g++ -shared -fPIC add.cpp sub.cpp -o libmath.so  # 创建动态库
     g++ main.cpp -L. -lmath -o main                  # 链接动态库
     ```

#### **链接顺序问题**：
- 链接器按顺序解析符号，需确保依赖关系正确。  
- 错误示例：`-lA -lB` 如果 `A` 依赖 `B`，应写为 `-lB -lA`。

---

### **4. 编译器优化**
编译器通过优化选项提升代码性能，常见优化级别：  
| 优化级别 | GCC/Clang 参数 | 说明                          |
|----------|----------------|-------------------------------|
| `-O0`    | 无优化         | 保留调试信息，编译速度快      |
| `-O1`    | 基础优化       | 减少代码大小，提高执行速度    |
| `-O2`    | 中级优化       | 常用优化级别，兼顾性能和安全  |
| `-O3`    | 激进优化       | 可能增加代码大小，适合计算密集型任务 |
| `-Os`    | 优化代码大小   | 在 `-O2` 基础上减少体积       |

**示例**：
```bash
g++ -O2 main.cpp -o main
```

---

### **5. 调试信息与符号表**
- **生成调试信息**：使用 `-g` 选项保留符号表和源码信息。  
  ```bash
  g++ -g main.cpp -o main
  ```
- **剥离调试信息**：发布时可移除调试信息以减小体积。  
  ```bash
  strip main
  ```

---

### **6. 编译器扩展与标准支持**
- **C++ 标准指定**：通过 `-std` 参数选择语言标准。  
  ```bash
  g++ -std=c++17 main.cpp       # 使用 C++17 标准
  clang++ -std=c++20 main.cpp   # 使用 C++20 标准
  ```
- **编译器扩展**：  
  - GCC/Clang 支持非标准语法（如 `__attribute__`），但可能影响可移植性。

---

### **7. 常用工具**
| 工具          | 用途                                  | 示例命令                      |
|---------------|---------------------------------------|-------------------------------|
| **objdump**   | 分析目标文件或可执行文件              | `objdump -d main.o`           |
| **nm**        | 查看目标文件中的符号表                | `nm main.o`                   |
| **ldd**       | 查看可执行文件依赖的动态库（Linux）   | `ldd main`                    |
| **otool**     | 查看依赖库（macOS）                   | `otool -L main`               |
| **readelf**   | 分析 ELF 格式文件（Linux）            | `readelf -s main.o`           |

---

### **8. 常见问题与解决**
1. **未定义符号（Undefined Symbols）**  
   - 检查是否遗漏了链接库（`-l` 参数）。  
   - 确保库的路径正确（`-L` 参数）。

2. **动态库加载失败**  
   - Linux：设置 `LD_LIBRARY_PATH` 或修改 `/etc/ld.so.conf`。  
   - Windows：确保 DLL 文件在 PATH 环境变量路径中。

3. **头文件路径错误**  
   - 使用 `-I` 指定头文件目录：  
     ```bash
     g++ -I/path/to/headers main.cpp
     ```

---

通过理解这些知识，你应该理解为什么要使用cmake等工具管理项目，这些工具能够帮助我们完成很多编译器配置，同时支持跨平台。